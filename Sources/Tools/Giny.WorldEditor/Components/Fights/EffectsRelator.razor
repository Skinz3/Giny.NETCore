@using Giny.IO.D2I;
@using Giny.IO.D2O;
@using Giny.IO.D2OClasses;
@using Giny.Protocol.Enums;
@using Giny.World.Managers.Fights.Effects;
@using Giny.World.Records.Breeds;
@using Giny.World.Records.Maps;
@using Giny.World.Records.Monsters;
@using Giny.World.Records.Spells;
@using Giny.WorldEditor.Config;
@using Microsoft.AspNetCore.Components.Web.Virtualization
@using Microsoft.AspNetCore.Components;
@using MudBlazor.Services;
@using System.Reflection;
@using System.Collections;
@using System.Collections.Concurrent;
@inject IDialogService DialogService



<MudGrid>

    <MudItem xs="2">
        <MudPaper Outlined=true>

            <MudList Dense="true" Clickable="true">


                <MudListSubheader>

                    <MudCheckBox @bind-Checked="@UnhandledOnly" Color="Color.Primary"> <MudText Typo="Typo.body2">  Non géré uniquement</MudText> </MudCheckBox>
                    <MudCheckBox @bind-Checked="@BreedSpellsOnly" Color="Color.Primary"><MudText Typo="Typo.body2"> Sorts de classe</MudText></MudCheckBox>

                    <MudTextField Label="Search" TextChanged=OnSearchTextChanged @bind-Value="@Search"
                                  AdornmentColor="Color.Primary" AdornmentIcon="@Icons.Filled.Search"
                                  Adornment="Adornment.End" Immediate="true" Variant="Variant.Outlined" />
                </MudListSubheader>

                <div style="height:70vh;overflow-y:scroll">

                    <Virtualize Items="@SearchResults">
                        <MudListItem OnClick="() => SelectEffect(context)" Text=@context.ToString() />
                    </Virtualize>
                </div>

            </MudList>

        </MudPaper>
    </MudItem>

    <MudItem xs="2">
        <MudPaper Outlined=true>

            <MudList Dense="true" Clickable="true">
                <MudListSubheader>
                    <MudText Typo="Typo.caption">@SelectedEffect</MudText>
                </MudListSubheader>

                <div style="height:80vh;overflow-y:scroll">

                    <Virtualize Items="@DisplayedSpells">
                         <MudListItem OnClick="() => DisplaySpell(context)" Value="context">

                            <div class="d-flex flex-row gap-3 align-center">
                                <MudIcon Icon="@Icons.Outlined.Workspaces" />
                                <div class="d-flex flex-column">
                                    <MudText Style="font-size:14px;line-height:16px;font-weight:600;">@context.Name</MudText>
                                    <MudText Typo=Typo.caption Style="line-height:16px">@(string.IsNullOrWhiteSpace(context.Description) ? "" : context.Description)</MudText>

                                </div>
                            </div>

                        </MudListItem>

                    </Virtualize>
                </div>

            </MudList>

        </MudPaper>
    </MudItem>

    <MudItem xs="8">
        <SpellComponent @ref="spellComponent"></SpellComponent>
    </MudItem>


</MudGrid>


@code {
    [CascadingParameter]
    public Home Parent
    {
        get;
        set;
    }
    private string Search
    {
        get;
        set;
    } = "";

    bool m_unhandledOnly;

    bool UnhandledOnly
    {
        get
        {
            return m_unhandledOnly;
        }
        set
        {
            m_unhandledOnly = value;
            OnInitialized();
        }
    }

    bool m_breedSpellsOnly;

    bool BreedSpellsOnly
    {
        get
        {
            return m_breedSpellsOnly;
        }
        set
        {
            m_breedSpellsOnly = value;
            OnInitialized();
        }
    }

    Dictionary<EffectsEnum, List<SpellRecord>> Effects = new Dictionary<EffectsEnum, List<SpellRecord>>();

    List<EffectsEnum> SearchResults = new();

    List<SpellRecord> DisplayedSpells = new();

    private SpellComponent spellComponent;

    private EffectsEnum SelectedEffect
    {
        get;
        set;
    }
    string GetSpellName(SpellRecord record)
    {

        return record.ToString();
    }

    private void OnSearchTextChanged()
    {
        SearchResults = Effects.Keys.Where(x => x.ToString().ToLower().Contains(Search.ToLower())).ToList();
        StateHasChanged();
    }
    private void SelectEffect(EffectsEnum effect)
    {
        SelectedEffect = effect;
        DisplayedSpells = Effects[effect].ToList();
    }

    private void DisplaySpell(SpellRecord record)
    {
        spellComponent.SelectSpell(record);
    }
    private void InternalLoad()
    {
        Effects.Clear();
        SearchResults.Clear();

        bool unhandledOnly = UnhandledOnly;
        bool breedSpellsOnly = BreedSpellsOnly;

        string searchStr = "";


        var spellRecords = SpellRecord.GetSpellRecords();
        int i = 0;
        int n = spellRecords.Count();

        var lastBreedId = BreedRecord.GetBreeds().Max(x => x.Id);

        foreach (var spell in spellRecords)
        {
            foreach (var level in spell.Levels)
            {
                foreach (var effect in level.Effects)
                {
                    if (SpellEffectManager.Instance.Exists(effect.EffectEnum) && unhandledOnly)
                    {
                        continue;
                    }


                    if ((level.SpellBreed < 0 || level.SpellBreed >= (short)lastBreedId) && breedSpellsOnly)
                    {
                        continue;
                    }

                    if (searchStr == string.Empty || effect.EffectEnum.ToString().ToLower().Contains(searchStr.ToLower()))
                    {
                        if (!Effects.ContainsKey(effect.EffectEnum))
                        {
                            Effects.Add(effect.EffectEnum, new List<SpellRecord>());

                        }

                        if (!Effects[effect.EffectEnum].Contains(spell))
                        {
                            Effects[effect.EffectEnum].Add(spell);
                        }
                    }
                }
            }
            i++;

        }

        SearchResults = Effects.Keys.ToList();
        StateHasChanged();
    }

    protected override void OnInitialized()
    {
        InternalLoad();
    }
}
