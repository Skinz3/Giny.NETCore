@using Giny.IO.D2I;
@using Giny.IO.D2O;
@using Giny.IO.D2OClasses;
@using Giny.Protocol.Enums;
@using Giny.World.Managers.Fights.Effects;
@using Giny.World.Records.Maps;
@using Giny.World.Records.Monsters;
@using Giny.World.Records.Spells;
@using Giny.WorldView.Config;
@using Microsoft.AspNetCore.Components.Web.Virtualization
@using Microsoft.AspNetCore.Components;
@using MudBlazor.Services;
@using System.Reflection;
@using System.Collections;
@using System.Collections.Concurrent;
@inject IDialogService DialogService



<MudGrid>

    <MudItem xs="3">
        <MudPaper Outlined=true>

            <MudList Dense="true" Clickable="true">


                <MudListSubheader>
                    <MudCheckBox @bind-Checked="@UnhandledOnly" Color="Color.Primary">Non géré uniquement</MudCheckBox>
                    <MudCheckBox @bind-Checked="@BreedSpellsOnly" Color="Color.Primary">Sorts de classe uniquement</MudCheckBox>
                    <MudTextField Label="Search" TextChanged=OnSearchTextChanged @bind-Value="@Search"
                                  AdornmentColor="Color.Primary" AdornmentIcon="@Icons.Filled.Search"
                                  Adornment="Adornment.End" Immediate="true" Variant="Variant.Outlined" />
                </MudListSubheader>

                <div style="height:70vh;overflow-y:scroll">

                    <Virtualize Items="@SearchResults">
                        <MudListItem OnClick="() => SelectEffect(context)" Text=@context.ToString() />
                    </Virtualize>
                </div>

            </MudList>

        </MudPaper>
    </MudItem>

    <MudItem xs="3">
        <MudPaper Outlined=true>

            <MudList Dense="true" Clickable="true">
                <MudListSubheader>
                    <MudText>Liste des sorts</MudText>
                </MudListSubheader>

                <div style="height:80vh;overflow-y:scroll">

                    <Virtualize Items="@DisplayedSpells">
                        <MudListItem OnClick="() => NavigateToSpell(context)" Text=@context.ToString() />
                    </Virtualize>
                </div>

            </MudList>

        </MudPaper>
    </MudItem>



</MudGrid>


@code {
    [CascadingParameter]
    public Home Parent
    {
        get;
        set;
    }
    private string Search
    {
        get;
        set;
    } = "";

    bool Ready
    {
        get;
        set;
    } = true;

    bool m_unhandledOnly;

    bool UnhandledOnly
    {
        get
        {
            return m_unhandledOnly;
        }
        set
        {
            m_unhandledOnly = value;
            OnInitialized();
        }
    }

    bool m_breedSpellsOnly;

    bool BreedSpellsOnly
    {
        get
        {
            return m_breedSpellsOnly;
        }
        set
        {
            m_breedSpellsOnly = value;
            OnInitialized();
        }
    }


    CancellationTokenSource CancelSource
    {
        get;
        set;
    }
    private Action OnCancel;

    Dictionary<EffectsEnum, List<SpellRecord>> Effects = new Dictionary<EffectsEnum, List<SpellRecord>>();

    List<EffectsEnum> SearchResults = new();

    List<SpellRecord> DisplayedSpells = new();

    private EffectsEnum SelectedEffect
    {
        get;
        set;
    }
    private void OnSearchTextChanged()
    {
        if (!Ready)
        {
            return;
        }
        SearchResults = Effects.Keys.Where(x => x.ToString().ToLower().Contains(Search.ToLower())).ToList();
        StateHasChanged();
    }
    private void SelectEffect(EffectsEnum effect)
    {
        if (!Ready)
        {
            return;
        }
        SelectedEffect = effect;
        DisplayedSpells = Effects[effect].ToList();
    }
    private void NavigateToSpell(SpellRecord record)
    {
        AppState.SpellExplorerTarget = record;
        Parent.Navigate(PageEnum.SpellExplorer);

    }
    private void InternalLoad()
    {

        Ready = false;
        InvokeAsync(() => StateHasChanged());

        Effects.Clear();
        SearchResults.Clear();
        CancelSource = new CancellationTokenSource();

        bool unhandledOnly = UnhandledOnly;
        bool breedSpellsOnly = BreedSpellsOnly;

        string searchStr = "";

        Task.Run(() =>
        {

            var spellRecords = SpellRecord.GetSpellRecords();
            int i = 0;
            int n = spellRecords.Count();

            foreach (var spell in spellRecords)
            {
                foreach (var level in spell.Levels)
                {
                    foreach (var effect in level.Effects)
                    {
                        if (SpellEffectManager.Instance.Exists(effect.EffectEnum) && unhandledOnly)
                        {
                            continue;
                        }

                        if ((level.SpellBreed < 0 || level.SpellBreed > (short)BreedEnum.Ouginak) && breedSpellsOnly)
                        {
                            continue;
                        }

                        if (searchStr == string.Empty || effect.EffectEnum.ToString().ToLower().Contains(searchStr.ToLower()))
                        {
                            if (!Effects.ContainsKey(effect.EffectEnum))
                            {
                                Effects.Add(effect.EffectEnum, new List<SpellRecord>());

                            }

                            if (!Effects[effect.EffectEnum].Contains(spell))
                            {
                                Effects[effect.EffectEnum].Add(spell);
                            }
                        }
                    }
                }
                i++;

                if (CancelSource.IsCancellationRequested)
                {
                    break;
                }


            }

            SearchResults = Effects.Keys.ToList();
            Ready = true;

            InvokeAsync(() => StateHasChanged());
        });
    }

    protected override void OnInitialized()
    {
        if (!Ready)
        {
            OnCancel = new Action(() =>
            {
                OnCancel = null;
                InternalLoad();
            });

            CancelSource.Cancel();

        }
        else
        {
            InternalLoad();
        }
    }
}
