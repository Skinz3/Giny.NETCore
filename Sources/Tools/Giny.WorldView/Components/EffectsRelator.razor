@using Giny.IO.D2I;
@using Giny.IO.D2O;
@using Giny.IO.D2OClasses;
@using Giny.Protocol.Enums;
@using Giny.World.Managers.Fights.Effects;
@using Giny.World.Records.Maps;
@using Giny.World.Records.Monsters;
@using Giny.World.Records.Spells;
@using Giny.WorldView.Config;
@using Microsoft.AspNetCore.Components.Web.Virtualization
@using Microsoft.AspNetCore.Components;
@using MudBlazor.Services;
@using System.Reflection;
@using System.Collections;
@using System.Collections.Concurrent;
@inject IDialogService DialogService


@if (Ready)
{
    <MudGrid>

        <MudItem xs="3">
            <MudPaper Outlined=true>

                <MudList Dense="true" Clickable="true">

                    <MudListSubheader>
                        <MudText>@(Effects.Keys.Count) effets.</MudText>
                        <MudCheckBox @bind-Checked="@UnhandledOnly" Color="Color.Primary">Non géré uniquement</MudCheckBox>
                        <MudTextField Label="Search" TextChanged=OnSearchTextChanged @bind-Value="@Search"
                                  AdornmentColor="Color.Primary" AdornmentIcon="@Icons.Filled.Search"
                                  Adornment="Adornment.End" Immediate="true" Variant="Variant.Outlined" />
                    </MudListSubheader>

                    <div style="height:70vh;overflow-y:scroll">

                        <Virtualize Items="@Effects.Keys.ToArray()">
                            <MudListItem OnClick="() => SelectEffect(context)" Text=@context.ToString() />
                        </Virtualize>
                    </div>

                </MudList>

            </MudPaper>
        </MudItem>



    </MudGrid>
}

@code {
    private string Search
    {
        get;
        set;
    } = "";

    bool Ready
    {
        get;
        set;
    }

    bool m_unhandledOnly;

    bool UnhandledOnly
    {
        get
        {
            return m_unhandledOnly;
        }
        set
        {
            m_unhandledOnly = value;
            OnInitialized();
        }
    }
 

    CancellationTokenSource CancelSource
    {
        get;
        set;
    }
    private Action OnCancel;

    Dictionary<EffectsEnum, List<SpellRecord>> Effects = new Dictionary<EffectsEnum, List<SpellRecord>>();

    private void OnSearchTextChanged()
    {

        StateHasChanged();
    }
    private void SelectEffect(EffectsEnum effect)
    {

    }

    private void InternalLoad()
    {

        InvokeAsync(() => StateHasChanged());

        Ready = false;


        Effects.Clear();

        CancelSource = new CancellationTokenSource();

        bool unhandledOnly = UnhandledOnly;

        string searchStr = "";

        Task.Run(() =>
        {

            var spellRecords = SpellRecord.GetSpellRecords();
            int i = 0;
            int n = spellRecords.Count();

            foreach (var spell in spellRecords)
            {
                foreach (var level in spell.Levels)
                {
                    foreach (var effect in level.Effects)
                    {
                        if (SpellEffectManager.Instance.Exists(effect.EffectEnum) && unhandledOnly)
                        {
                            continue;
                        }

                        if (searchStr == string.Empty || effect.EffectEnum.ToString().ToLower().Contains(searchStr.ToLower()))
                        {
                            if (!Effects.ContainsKey(effect.EffectEnum))
                            {
                                Effects.Add(effect.EffectEnum, new List<SpellRecord>());

                            }

                            if (!Effects[effect.EffectEnum].Contains(spell))
                            {
                                Effects[effect.EffectEnum].Add(spell);
                            }
                        }
                    }
                }
                i++;

                if (CancelSource.IsCancellationRequested)
                {
                    break;
                }


            }

            Ready = true;

            InvokeAsync(() => StateHasChanged());
        });
    }

    protected override void OnInitialized()
    {
        if (!Ready)
        {
            OnCancel = new Action(() =>
            {
                OnCancel = null;
                InternalLoad();
            });

            CancelSource.Cancel();

        }
        else
        {
            InternalLoad();
        }
    }
}
